// SPDX-License-Identifier: BSD-3-Clause
pragma solidity ^0.8.23;

import {CCTPBridgeActions} from "../BridgeScripts.sol";
import "./Strings.sol";

library BridgeRoutes {
    enum BridgeType {
        NONE,
        CCTP
    }

    error BridgeNotFound(uint256 srcChainId, uint256 dstChainId, string assetSymbol);

    struct Bridge {
        uint256 chainId;
        address outgoingAddress;
        BridgeType bridgeType;
    }

    function hasBridge(uint256 srcChainId, uint256 dstChainId, string memory assetSymbol)
        internal
        pure
        returns (bool)
    {
        if (getBridge(srcChainId, dstChainId, assetSymbol).bridgeType == BridgeType.NONE) {
            return false;
        } else {
            return true;
        }
    }

    // TODO: actually consider dstChainId before returning a bridge?
    // TODO: resolve assetSymbol to address before trying to bridge?
    // TODO: how do we represent the constant information about existing bridges? without mappings, etc.
    function getBridge(uint256 srcChainId, uint256 /*dstChainId*/, string memory assetSymbol)
        internal
        pure
        returns (Bridge memory bridge)
    {
        if (CCTP.canBridge(srcChainId, assetSymbol)) {
            bridge = Bridge({
                chainId: srcChainId,
                outgoingAddress: CCTP.knownOutgoingAddress(srcChainId),
                bridgeType: BridgeType.CCTP
            });
        }
    }
}

// NOTE: this library would be generated by a network crawler script.
library CCTP {
    // IDEA: input this into codegen, get out knownDomainId and knownOutgoingAddress functions?
    struct Roots {
        uint256 chainId;
        uint256 domainId;
        address outgoingAddress;
    }

    error NoKnownBridge(string bridgeType, uint256 chainId);
    error NoKnownDomainId(string bridgeType, uint256 chainId);

    function knownDomainId(uint256 chainId) internal pure returns (uint32) {
        if (chainId == 1) {
            return 0;
        } else if (chainId == 8453) {
            return 6;
        } else {
            revert NoKnownDomainId("CCTP", chainId);
        }
    }

    function knownOutgoingAddress(uint256 chainId) internal pure returns (address) {
        if (chainId == 1) {
            return 0xBd3fa81B58Ba92a82136038B25aDec7066af3155;
        } else if (chainId == 8453) {
            return 0x1682Ae6375C4E4A97e4B583BC394c861A46D8962;
        } else {
            revert NoKnownBridge("CCTP", chainId);
        }
    }

    function canBridge(uint256 chainId, string memory assetSymbol) internal pure returns (bool) {
        return Strings.stringEqIgnoreCase(assetSymbol, "USDC")
            && knownOutgoingAddress(chainId) != address(0);
    }

    function encodeBridgeUSDC(
        uint256 originChainId,
        uint256 destChainId,
        uint256 amount,
        address recipient,
        address usdc
    ) internal pure returns (bytes memory) {
        return abi.encodeCall(
            CCTPBridgeActions.bridgeUSDC,
            (knownOutgoingAddress(originChainId), amount, knownDomainId(destChainId), bytes32(uint256(uint160(recipient))), usdc)
        );
    }
}
